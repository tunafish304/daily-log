
# Git Command Cheat Sheet for Students

## 1. Starting a New Local Repository

```bash
git init
```
Initializes a new Git repository in the current folder.

```bash
ls -a
```
Confirms that the `.git` folder was created.

---

## 2. Connecting to a Remote Repository

```bash
git remote add origin <your-repo-url>
```
Links your local repo to a remote GitHub repository. Only run this once.

```bash
git remote -v
```
Shows the current remote connections.

---

## 3. Changing the Remote URL (if needed)

```bash
git remote set-url origin <new-repo-url>
```
Updates the remote URL if it was added incorrectly or needs to be changed.

---

## 4. Checking Your Branch Name

```bash
git branch
```
Shows your current branch. Most setups use `main`, but older ones may use `master`.

---

## 5. Adding and Committing Changes

```bash
git add .
```
Stages all changes in the current directory.

```bash
git commit -m "Your commit message"
```
Commits staged changes with a message.

---

## 6. Pushing to GitHub

```bash
git push -u origin main
```
Pushes your code to the `main` branch on GitHub and sets it as the default upstream branch.

```bash
git push
```
After the first push, this is all you need to push future changes.

---

## 7. Pulling Changes from GitHub

```bash
git pull
```
Fetches and merges changes from the remote repository.

---

## 8. Checking Status and History

```bash
git status
```
Shows which files are staged, modified, or untracked.

```bash
git log
```
Displays commit history.

---

## 9. Fixing Submodule Warnings

If you accidentally initialized Git inside a subfolder (like `.vscode`), run:

```bash
git rm --cached .vscode
rm -rf .vscode/.git
```

This removes the nested Git repo and prevents submodule issues.

---

## 10. Cloning a Repository

```bash
git clone <repo-url>
```
Creates a local copy of a remote repository.

---

## 11. Undoing Mistakes

```bash
git reset --soft HEAD~1
```
Undo the last commit but keep changes staged.

```bash
git restore <filename>
```
Restore a file to its last committed state.

```bash
git clean -fd
```
Remove untracked files and folders (use with caution).

---

## Notes

- Always activate your virtual environment before installing or running anything.
- Avoid running `git init` inside subfolders unless you intend to create a separate repository.
- Use `git push -u origin <branch>` only once per branch to set the upstream.

## Keeping track of git commands
```bash
echo "=== $(date) ===" >> gitCommands.txt
history | grep git >> gitCommands.txt
```

## Keeping a living cheat sheet

```bash
# Initialized Git repo and added remote
git init
git remote add origin https://github.com/username/project.git

# First commit and push
git add .
git commit -m "Initial commit"
git push -u origin main
```
Note: The problem here is that all the git commands get commited each time.
A better way:
```bash
Exactly—you nailed the issue. If students run:

```bash
history | grep git >> gitCommands.txt
```

every time, they’ll keep appending **all** their Git commands, including duplicates from earlier sessions. To avoid that, they need to **track the starting history number** and only grab new commands since that point.

Here’s how they can do it:

---

### Step-by-Step: Logging Git Commands from a Specific History Number

#### 1. **Check the current history number**
```bash
history
```
Look at the number of the last command. Let’s say it’s `512`.

#### 2. **Next time, filter from that number onward**
Use `awk` to filter by history number:
```bash
history | awk '$1 >= 513' | grep git >> gitCommands.txt
```
This grabs only Git commands with history numbers **513 and above**.

---

### Pro Tip: Automate It with a Marker

Students can add a marker comment to their log:
```bash
echo "# Git commands after history 512" >> gitCommands.txt
```
Then run the filtered command.

---

### Optional: Save the Last History Number


Store the last history number in a file:
```bash
history | tail -1 | awk '{print $1}' > last_history.txt
```
Then read it back later to filter:
```bash
start=$(cat last_history.txt)
history | awk -v s="$start" '$1 > s' | grep git >> gitCommands.txt
```

In `awk`, the `-v` flag **does not mean verbose**. Instead, it’s used to **pass a shell variable into the `awk` program**.

Here’s what it does:

```bash
awk -v s="$start" '$1 > s'
```

This means:
- `-v s="$start"` assigns the shell variable `$start` to an `awk` variable named `s`
- Then inside the `awk` program, `$1 > s` compares the first field (the history number) to that value

So it’s a way to **bridge shell and `awk`**, letting you use shell variables inside your `awk` logic.

---

###  Reusable Shell Script: `log_git_commands.sh`

Here’s a simple script you can use to log only **new Git commands** since their last save:

```bash
#!/bin/bash

# File to store last history number
HISTORY_MARKER="last_history.txt"
LOG_FILE="gitCommands.txt"

# Get current history number
CURRENT=$(history | tail -1 | awk '{print $1}')

# If marker file doesn't exist, start from 0
if [ ! -f "$HISTORY_MARKER" ]; then
    echo 0 > "$HISTORY_MARKER"
fi

# Read last saved history number
START=$(cat "$HISTORY_MARKER")

# Append new Git commands to log
echo "# Git commands after history $START" >> "$LOG_FILE"
history | awk -v s="$START" '$1 > s' | grep git >> "$LOG_FILE"

# Update marker
echo "$CURRENT" > "$HISTORY_MARKER"

echo "Logged new Git commands to $LOG_FILE"
```

### How to Use It

1. Save it as `log_git_commands.sh`
2. Make it executable:
   ```bash
   chmod +x log_git_commands.sh
   ```
3. Run it anytime:
   ```bash
   ./log_git_commands.sh
   ```

Each time you run it, it will:
- Log only new Git commands
- Add a comment with the starting history number
- Update the marker for next time
